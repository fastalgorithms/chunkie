function [fints,ids] = chunkerkerneval_stokes(chnkobj,kern,dens,targobj,opts)
%CHUNKERKERNEVAL compute the convolution of the integral kernel with
% the density defined on the chunk geometry. 
%
% Syntax: fints = chunkerkerneval(chnkr,kern,dens,targs,opts)
%
% Input:
%   chnkobj - chunker object or chunkgraph object description of curve
%   kern - kernel class object or kernel function taking inputs 
%                      kern(srcinfo,targinfo). if matrix of kernels 
%                      then must have dimensions nregion x nedge or 
%                      nregion x 1 or 1 x nedge, where nregion is the
%                      number of regions in the chunkgraph and nedge is the
%                      number of edges
%   dens - density on boundary, should have size opdims(2) x k x nch
%          where k = chnkr.k, nch = chnkr.nch, where opdims is the 
%          size of kern for a single src,targ pair.
%   targobj - object describing the target points, can be specified as
%       * array of points
%       * chunker object
%       * chunkgraph object
%
% Optional input:
%   opts - structure for setting various parameters
%       opts.flam - if = true, use flam utilities. to be replaced by the 
%                   opts.forceflam flag. 
%                   opts.flam supercedes opts.accel, if
%                   both are true, then flam will be used. (false)
%       opts.accel - if = true, use specialized fmm if defined 
%                   for the kernel or use a generic FLAM fmm to accelerate
%                   the smooth part of the eval. if false do direct. (true)
%       opts.proxybylevel - if = true, determine the number of
%                   necessary proxy points adaptively at each level of the 
%                   factorization in ifmm. Typically needed only for 
%                   moderate / high frequency problems. (false)
%                   for the kernel, if it doesnt exist or if too few 
%                   sources/targets, or if false, 
%                   do direct. (true)
%       opts.forcefmm - if = true, use specialized fmm if defined,
%                   independent of the number of sources/targets. (false)
%       opts.forcesmooth - if = true, only use the smooth integration rule
%                           (false)
%       opts.cormat - sparse matrix of corrections to the smooth quadrature rule
%            generated by chunkerkernevalmat with option corrections =
%            true, useful if there are repeated calls with the same targets points
%       opts.forceadap - if = true, only use adaptive quadrature (false)
%    NOTE: only one of forcesmooth or forceadap is allowed. If both 
%           false, a hybrid algorithm is used, where the smooth rule is 
%           applied for targets separated by opts.fac*length of chunk from
%           a given chunk and adaptive integration is used otherwise
%       opts.fac = the factor times the chunk length used to decide 
%               between adaptive/smooth rule
%       opts.eps = tolerance for adaptive integration
%
% output:
%   fints - opdims(1) x nt array of integral values where opdims is the 
%           size of kern for a single input (dimension of operator output)
%   ids - a size nt integer array. if chnkrobj is a chunkgraph, ids(i) is
%           the ID number of the region containing the ith target. if
%           chnkrobj is a chunker, then ids is simply an array of all 1s.
%

% TODO: find a method for using proxy surfaces while still not performing
%   the add/subtract strategy...

% author: Travis Askham (askhamwhat@gmail.com)

% determine operator dimensions using first two points

% Assign appropriate object to chnkr
icgrph = false;
nregion = 1;
nedge = 1;
if class(chnkobj) == "chunker"
   chnkr = chnkobj;
   nedge = length(chnkr);
elseif class(chnkobj) == "chunkgraph"
   chnkr = chnkobj.echnks;
   nregion = length(chnkobj.regions);
   nedge = length(chnkr);
   icgrph = true;
else
    msg = "CHUNKERKERNEVAL: first input is an unsupported object";
    error(msg)
end

if ~isa(kern,'kernel')
    try 
        kern = kernel(kern);
    catch
        error('CHUNKERKERNEVAL: second input kern not of supported type');
    end
end

[mk,nk] = size(kern);
assert(or(mk == 1,mk == nregion),...
    "CHUNKERKERNEVAL: second input not of appropriate shape " + ...
    "number of rows in kern should be 1 or nregion")
assert(or(nk == 1,nk == nedge),...
    "CHUNKERKERNEVAL: second input not of appropriate shape " + ...
    "number of cols in kern should be 1 or nedge")

if nk == 1 && length(chnkr) > 1
    chnkr = merge(chnkr);
end


if nargin < 5
    opts = [];
end

opts_use = [];
opts_use.forcesmooth = false;
opts_use.forceadap = false;
opts_use.forcepquad = false;
opts_use.flam = false;
opts_use.accel = true;
opts_use.forcefmm = false;
opts_use.fac = 1.0;
opts_use.eps = 1e-12;
opts_use.proxybylevel = false;
cormat = [];
if isfield(opts,'forcesmooth'); opts_use.forcesmooth = opts.forcesmooth; end
if isfield(opts,'forceadap'); opts_use.forceadap = opts.forceadap; end
if isfield(opts,'forcepquad'); opts_use.forcepquad = opts.forcepquad; end
if isfield(opts,'side'); opts_use.side = opts.side; end
if isfield(opts,'flam')
    opts_use.flam = opts.flam;
end
if isfield(opts,'cormat')
    cormat = opts.cormat;
    opts_use.forcesmooth = true;
    opts_use.forceadap = false;
    opts_use.forcepquad = false;
end
if isfield(opts,'accel'); opts_use.accel = opts.accel; end
if isfield(opts,'fac'); opts_use.fac = opts.fac; end
if isfield(opts,'eps'); opts_use.eps = opts.eps; end
if isfield(opts,'proxybylevel'); opts_use.proxybylevel = opts.proxybylevel; end

% Assign appropriate object to targinfo
targinfo = [];
if isa(targobj, "chunker") || isa(targobj, "chunkgraph")
    targinfo.r = targobj.r(:,:);
    targinfo.d = targobj.d(:,:);
    targinfo.d2 = targobj.d2(:,:);
    targinfo.n = targobj.n(:,:);
elseif isstruct(targobj)
    if isfield(targobj,"r")
        targinfo.r = targobj.r(:,:);
    else
        error("CHUNKERKERNEVAL: input 4 must at least have positions " + ...
            "defined");
    end
    if isfield(targobj,"d"); targinfo.d = targobj.d(:,:); end
    if isfield(targobj,"d2"); targinfo.d2 = targobj.d2(:,:); end
    if isfield(targobj,"n"); targinfo.n = targobj.n(:,:); end
    if isfield(targobj,"data"); targinfo.data = targobj.data(:,:); end
elseif isnumeric(targobj)
    targinfo.r = targobj;
else
    error("CHUNKERKERNEVAL: input 4 is not a supported type");
end

if icgrph && mk > 1
    ids = chunkgraphinregion(chnkobj,targinfo.r);
else
    ids = ones(size(targinfo.r,2),1);
end

[dim,~] = size(targinfo.r);

if (dim ~= 2); warning('only dimension two tested'); end

opdims_mat = zeros(2,mk,nk);
ntargs = zeros(mk,1);
npts = zeros(nk,1);

datadim = 0;
if isfield(targinfo,'data') && ~isempty(targinfo.data)
    datadim = size(targinfo.data,1);
end

for iii=1:mk
    itarg = (ids == iii);    
    ntargs(iii) = nnz(itarg);

    targinfotmp = [];
    targinfotmp.r = randn(dim,1); targinfotmp.d = randn(dim,1);
    targinfotmp.d2 = randn(dim,1); targinfotmp.n = randn(dim,1);
    targinfotmp.data = randn(datadim,1);
    
    for jjj=1:nk
        
        % determine operator dimensions using a boundary point and random
        % targ
        
        srcinfo = []; 
        srcinfo.r = chnkr(jjj).r(:,1); srcinfo.d = chnkr(jjj).d(:,1); 
        srcinfo.d2 = chnkr(jjj).d2(:,1); srcinfo.n = chnkr(jjj).n(:,1);
        if ~isempty(chnkr(jjj).data)
            srcinfo.data = chnkr(jjj).data(:,1);
        end
        npts(jjj) = chnkr(jjj).npt; 

        try
            ftemp = kern(iii,jjj).eval(srcinfo,targinfotmp);
        catch
            error("failed to determine size of kernel (%d, %d)",iii,jjj);
        end
        opdims = size(ftemp);
        opdims_mat(:,iii,jjj) = opdims;
    end
end    

% indexing

icollocs = zeros(nk+1,1);
icollocs(1)=1;
for jjj=1:nk
    icollocs(jjj+1) = icollocs(jjj) + npts(jjj)*opdims_mat(2,1,jjj);
end

rowdims = opdims_mat(1,:,1); rowdims = rowdims(:);
nout = sum(ntargs(:).*rowdims(:));
fints = zeros(nout,1);
if ~isempty(cormat)
    if nout ~= size(cormat,1)
        error('cormat size is incorrect\n')
    end
end

ntarg = size(targinfo.r(:,:),2);
itargstart = zeros(ntarg+1,1);
itargstart(2:end) = rowdims(ids(:));
itargstart = 1+cumsum(itargstart);

for iii = 1:mk
% loop over relevant regions 
itarg = (ids == iii);
if nnz(itarg) == 0
    continue
end

targinfo0 = [];
targinfo0.r = targinfo.r(:,itarg);
if isfield(targinfo,"d"); targinfo0.d = targinfo.d(:,itarg); end
if isfield(targinfo,"d2"); targinfo0.d2 = targinfo.d2(:,itarg); end
if isfield(targinfo,"n"); targinfo0.n = targinfo.n(:,itarg); end
if isfield(targinfo,"data") && ~isempty(targinfo.data); targinfo0.data = targinfo.data(:,itarg); end

irow0 = kron(itargstart(itarg),ones(rowdims(iii),1)) + repmat( (0:(rowdims(iii)-1)).',nnz(itarg),1);

for jjj = 1:nk
% loop over relevant boundary components

kern0 = kern(iii,jjj);
if kern0.isnan
    fints(irow0) = nan;
    continue
end
if kern0.iszero
    continue
end

chnkr0 = chnkr(jjj);
opdims0 = opdims_mat(:,iii,jjj);
dens0 = dens(icollocs(jjj):(icollocs(jjj+1)-1));

if opts_use.forcesmooth
    fints(irow0) = fints(irow0) + chnk.chunkerkerneval_smooth(chnkr0,kern0,opdims0,dens0,targinfo0, ...
        [],opts_use);
    continue
end

if opts_use.forceadap
    fints(irow0) = fints(irow0) + chunkerkerneval_adap(chnkr0,kern0,opdims0,dens0, ...
        targinfo0,[],opts_use);
    continue
end


if opts_use.forcepquad
    optsflag = []; optsflag.fac = opts_use.fac;
    flag = flagnear(chnkr0,targinfo.r,optsflag);
    fints(irow0) = fints(irow0) + chnk.chunkerkerneval_smooth(chnkr0,kern0,opdims0,dens0,targinfo0, ...
        flag,opts_use);

    if ~isfield(opts_use,'side')
        msg = "Error: for pquad, set opts.side to 'i' or 'e' ";
        error(msg)  
    end

    fints(irow0) = fints(irow0) + chunkerkerneval_pquad(chnkr0,kern0,opdims0,dens0, ...
        targinfo0,flag,opts_use);

    return
end

% smooth for sufficiently far, adaptive otherwise

rho = 1.8;
optsflag = [];  optsflag.rho = rho;
flag = flagnear_rectangle(chnkr0,targinfo0.r,optsflag);

npoly = chnkr0.k*2;
nlegnew = chnk.ellipse_oversample(rho,npoly,opts_use.eps);
nlegnew = max(nlegnew,chnkr0.k);

[chnkr02,dens02] = upsample(chnkr0,nlegnew,dens0);
fints(irow0) = fints(irow0) + chnk.chunkerkerneval_smooth(chnkr02,kern0,opdims0,dens02,targinfo0, ...
    flag,opts_use);

fints(irow0) = fints(irow0) + chunkerkerneval_adap(chnkr0,kern0,opdims0,dens0, ...
        targinfo0,flag,opts_use);

end
end

if ~isempty(cormat)
    fints = fints + cormat*dens;
end

end

function fints = chunkerkerneval_pquad(chnkr,kern,opdims,dens, ...
    targinfo,flag,opts)

if ~isa(kern,'kernel') || isempty(kern.splitinfo)
    error('Helsing-Ojala quad only available for kernel class objects with splitinfo defined');
end

% target
[~,nt] = size(targinfo.r);
fints = zeros(opdims(1)*nt,1);
k = chnkr.k;
nch = chnkr.nch;
[t,w] = lege.exps(2*k);
ct = lege.exps(k);
bw = lege.barywts(k);
r = chnkr.r;
d = chnkr.d;
n = chnkr.n;
d2 = chnkr.d2;
wts = chnkr.wts;

assert(numel(dens) == opdims(2)*k*nch,'dens not of appropriate size')
dens = reshape(dens,opdims(2),k,nch);

% interpolation matrix
intp = lege.matrin(k,t);          % interpolation from k to 2*k
intp_ab = lege.matrin(k,[-1;1]);  % interpolation from k to end points

targs = targinfo.r;

for j=1:size(chnkr.r,3)
    [ji] = find(flag(:,j));
    if(~isempty(ji))
        idxjmat = (j-1)*k+(1:k);

        targinfoji = [];
        targinfoji.r = targinfo.r(:,ji);
        if isfield(targinfo, 'd')
            targinfoji.d = targinfo.d(:,ji);
        end

        if isfield(targinfo, 'd2')
            targinfoji.d2 = targinfo.d2(:,ji);
        end

        if isfield(targinfo, 'n')
            targinfoji.n = targinfo.n(:,ji);
        end        

        srcinfo = [];
        srcinfo.r = r(:,:,j);
        srcinfo.d = d(:,:,j);
        srcinfo.d2 = d2(:,:,j);
        srcinfo.n = n(:,:,j);
        densj = dens(:,:,j);
        indji = (ji-1)*opdims(1);
        ind = (indji(:)).' + (1:opdims(1)).';

        % Helsing-Ojala (interior/exterior?)
        allmats = cell(size(kern.splitinfo.type));
        [allmats{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji), ...
              t,w,opts,intp_ab,intp,kern.splitinfo.type);

        fints2 = fints;
        fints3 = fints;
        fints4 = fints;
        fints5 = fints;
        %
        fintsD2 = fints;
        funs = kern.splitinfo.functions(srcinfo,targinfoji);
        %
        fintsStrac2 = fints;
        %
        fintsDtrac2 = fints;
        %
        fintsSpres2 = fints;
        %
        fintsDpres2 = fints;
        %
        mu = 1; 
        ntarg = numel(ji);
        nsrc = k;
        
        fints = fints4;

        densjT = densj.'; % switch from interleaving
        %% what should be the singularity type of Stokes SLP velocity kernel
        if strcmp(kern.type, 'svel')
          % fints5
          As = allmats{1};
          Ad = allmats{2};
          Asz = Ad.*repmat(conj(1i*(srcinfo.n(1,:)+1i*srcinfo.n(2,:)))/1i,[numel(ji) 1]);
          A1 = real(Asz); 
          A2 = -imag(Asz);
          cdist = -(targs(1,ji)'+1i*targs(2,ji)') + (r(1,:,j)+1i*r(2,:,j));
          %
          S11p1iS21 = (As/2+A1.*cdist/2);
          S12p1iS22 = (1i*As/2+A2.*cdist/2);
          Acorrc = [S11p1iS21,S12p1iS22];
          Acorrtmp = [real(Acorrc);imag(Acorrc)];
          Acorr = zeros(size(Acorrtmp));
          Acorr(1:2:end) = real(Acorrc);
          Acorr(2:2:end) = imag(Acorrc);
          %
          fints5(ind(:)) = fints5(ind(:)) + Acorr*densjT(:);
  
          fints = fints5;
        end
        
        
        %% what should be the singularity type of Stokes DLP velocity kernel
        if strcmp(kern.type, 'dvel')
          allmats = cell(size(kern.splitinfo.type));
          kern.splitinfo.type{3} = [0 0 -2 0];
          [allmats{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji), ...
                t,w,opts,intp_ab,intp,kern.splitinfo.type);
  
          A = allmats{2};
          Az = allmats{3};
  
          rfnx = srcinfo.n(1,:) + 1i*srcinfo.n(2,:);
          rfx = srcinfo.r(1,:) + 1i*srcinfo.r(2,:);
          px = targs(1,ji)'+1i*targs(2,ji)';
          dinx = A.*(ones(ntarg,1)*(1./rfnx)); dnx = ones(ntarg,1)*rfnx;
          D11p1iD21 = (-conj(Az).*real(bsxfun(@minus,px,rfx)) +real(dinx).*dnx);
          D12p1iD22 = (-conj(Az).*imag(bsxfun(@minus,px,rfx)) -imag(dinx).*dnx);
          Acorrc = [D11p1iD21,D12p1iD22];
          Acorrtmp = [real(Acorrc);imag(Acorrc)];
          Acorr = zeros(size(Acorrtmp));
          Acorr(1:2:end) = real(Acorrc);
          Acorr(2:2:end) = imag(Acorrc);
          %
          fintsD2(ind(:)) = fintsD2(ind(:)) + Acorr*densjT(:);
          % 
          % fints(ind(1,:)) = fints(ind(1,:)) + real(Acorr)*densjT(:);
          % fints(ind(2,:)) = fints(ind(2,:)) + imag(Acorr)*densjT(:);
          % 
          % 
          fints = fintsD2;
          % keyboard
        end

        %% what should be the singularity type of Stokes SLP traction kernel
        if strcmp(kern.type, 'strac')
          % fintsStrac2
          allmats = cell(2,1);
          kernsplitinfotype = cell(2,1);
          kernsplitinfotype{1} = [0 0 -1 0];
          kernsplitinfotype{2} = [0 0 -2.1 0];
          [allmats{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji), ...
                t,w,opts,intp_ab,intp,kernsplitinfotype);
          Sz = allmats{1};
          Dz = allmats{2};
          px = targinfoji.r(1,:)'+1i*targinfoji.r(2,:)';
          pnx = targinfoji.n(1,:)'+1i*targinfoji.n(2,:)';
          rfx = srcinfo.r(1,:)+1i*srcinfo.r(2,:);
          rfnx = srcinfo.n(1,:)+1i*srcinfo.n(2,:);
          gsdotnx = real((pnx*ones(1,k)).*Sz); % grad slp dot nx
          gdinyrdotny =  Dz.*(ones(ntarg,1)*(1./rfnx)).*real(conj(bsxfun(@minus,px,rfx)).*(pnx*ones(1,k)));   % grad D/nx times r dot ny
          Sp11p1iSp21 = (gsdotnx+conj(gdinyrdotny));
          Sp12p1iSp22 = (1i*gsdotnx-1i*conj(gdinyrdotny));
          Acorrc = [Sp11p1iSp21,Sp12p1iSp22];
          Acorrtmp = [real(Acorrc);imag(Acorrc)];
          Acorr = zeros(size(Acorrtmp));
          Acorr(1:2:end) = real(Acorrc);
          Acorr(2:2:end) = imag(Acorrc);
          %
          fintsStrac2(ind(:)) = fintsStrac2(ind(:)) + Acorr*densjT(:);
          %
          fints = fintsStrac2;

        end

        %% what should be the singularity type of Stokes DLP traction kernel
        if strcmp(kern.type, 'dtrac')
          % fintsDtrac2
          kernsplitinfotype = cell(2,1);
          kernsplitinfotype{1} = [0 0 -2 0];
          kernsplitinfotype{2} = [0 0 -3.1 0];
          allmats3 = cell(2,1);
          [allmats3{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji), ...
              t,w,opts,intp_ab,intp,kernsplitinfotype);
          %
          Az = allmats3{1};
          Azz = allmats3{2};
          %
          px = targinfoji.r(1,:)'+1i*targinfoji.r(2,:)';
          pnx = targinfoji.n(1,:)'+1i*targinfoji.n(2,:)';
          rfx = srcinfo.r(1,:)+1i*srcinfo.r(2,:);
          rfnx = srcinfo.n(1,:)+1i*srcinfo.n(2,:);
          %
          hx11   = -4*real(Azz).*real((px-rfx).*(conj(pnx)*ones(1,numel(rfx))));  % (s.ws(testn)*(-Hx)/pi)
          dxr11  =  real(Az).*(real(pnx)*ones(1,numel(rfx)));   % (Dxr*s.ws(testn)/(2*pi).*nx(:,1))
          dxi11  = -3*imag(Az).*(imag(pnx)*ones(1,numel(rfx)));    % (-3*Dxi*s.ws(testn)/(2*pi).*nx(:,2))
          dxrc11 =  real(Az.*(ones(numel(px),1)*(conj(rfnx)./rfnx))).*(real(pnx)*ones(1,numel(rfx)));    % (Dxrc*s.ws(testn)/(2*pi).*nx(:,1))
          dxic11 = -imag(Az.*(ones(numel(px),1)*(conj(rfnx)./rfnx))).*(imag(pnx)*ones(1,numel(rfx)));    % (-(Dxic*s.ws(testn)/(2*pi).*nx(:,2)))
          %
          T11 = hx11+dxr11+dxi11+dxrc11+dxic11;
          %
          hx12   =  4*imag(Azz).*real((px-rfx).*(conj(pnx)*ones(1,numel(rfx))));
          dxr12  = -real(Az).*(imag(pnx)*ones(1,numel(rfx)));
          dxi12  =  imag(Az).*(real(pnx)*ones(1,numel(rfx))); 
          dxrc12 = -real(Az.*(ones(numel(px),1)*(conj(rfnx)./rfnx))).*(imag(pnx)*ones(1,numel(rfx)));
          dxic12 = -imag(Az.*(ones(numel(px),1)*(conj(rfnx)./rfnx))).*(real(pnx)*ones(1,numel(rfx)));
          %
          T12 = hx12+dxr12+dxi12+dxrc12+dxic12;
          %
          hx22   =  4*real(Azz).*real((px-rfx).*(conj(pnx)*ones(1,numel(rfx))));
          dxr22  =  3*real(Az).*(real(pnx)*ones(1,numel(rfx)));
          dxi22  = -imag(Az).*(imag(pnx)*ones(1,numel(rfx)));
          dxrc22 = -real(Az.*(ones(numel(px),1)*(conj(rfnx)./rfnx))).*(real(pnx)*ones(1,numel(rfx)));
          dxic22 =  imag(Az.*(ones(numel(px),1)*(conj(rfnx)./rfnx))).*(imag(pnx)*ones(1,numel(rfx)));
          %
          T22 = hx22+dxr22+dxi22+dxrc22+dxic22;
          Acorrc = [T11,T12]+1i*[T12,T22];
          %
          Acorrtmp = [real(Acorrc);imag(Acorrc)];
          Acorr = zeros(size(Acorrtmp));
          Acorr(1:2:end) = real(Acorrc);
          Acorr(2:2:end) = imag(Acorrc);
          %
          fintsDtrac2(ind(:)) = fintsDtrac2(ind(:)) + Acorr*densjT(:);
          %
          fints = fintsDtrac2;

        end

        %% what should be the singularity type of Stokes SLP pressure kernel
        if strcmp(kern.type, 'spres')
          densjT = densj.'; % switch from interleaving
          % fintsSpres2
          kernsplitinfotype = cell(1,1);
          kernsplitinfotype{1} = [0 0 -1.1 0];
          allmats3 = cell(1,1);
          [allmats3{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji), ...
              t,w,opts,intp_ab,intp,kernsplitinfotype);
          %
          A = allmats3{1};
          %
          px = targinfoji.r(1,:)'+1i*targinfoji.r(2,:)';
          pnx = targinfoji.n(1,:)'+1i*targinfoji.n(2,:)';
          rfx = srcinfo.r(1,:)+1i*srcinfo.r(2,:);
          rfnx = srcinfo.n(1,:)+1i*srcinfo.n(2,:);
          %
          ny1 = real(rfnx); ny2 = imag(rfnx);
          Ar = real(A); Ai = imag(A);
          Acorr = [(Ar.*(ones(numel(px),1)*ny1(:)')+Ai.*(ones(numel(px),1)*ny2(:)')), ...
                   (Ar.*(ones(numel(px),1)*ny2(:)')-Ai.*(ones(numel(px),1)*ny1(:)'))];
          fintsSpres2(ind(:)) = fintsSpres2(ind(:)) + Acorr*densjT(:);
          fints = fintsSpres2;
          % keyboard
        end

        %% what should be the singularity type of Stokes DLP pressure kernel
        if strcmp(kern.type, 'dpres')
          densjT = densj.'; % switch from interleaving
          % fintsSpres2
          kernsplitinfotype = cell(2,1);
          kernsplitinfotype{1} = [0 0 0 0];
          kernsplitinfotype{2} = [0 0 -2.1 0];
          allmats3 = cell(2,1);
          [allmats3{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji), ...
              t,w,opts,intp_ab,intp,kernsplitinfotype);
          %
          Az = allmats3{2};
          Acorr = [-2*real(Az), 2*imag(Az)];
          fintsDpres2(ind(:)) = fintsDpres2(ind(:)) + Acorr*densjT(:);
          fints = fintsDpres2;
          % keyboard
        end

    end
end
end



function fints = chunkerkerneval_adap(chnkr,kern,opdims,dens, ...
    targinfo,flag,opts)

if isa(kern,'kernel')
    kerneval = kern.eval;
else
    kerneval = kern;
end

k = chnkr.k;
nch = chnkr.nch;

if nargin < 6
    flag = [];
end
if nargin < 7
    opts = [];
end

assert(numel(dens) == opdims(2)*k*nch,'dens not of appropriate size')
dens = reshape(dens,opdims(2),k,nch);

% Extract target info
targs = targinfo.r;
[~,nt] = size(targs);
targd = zeros(chnkr.dim,nt); targd2 = zeros(chnkr.dim,nt);
targn = zeros(chnkr.dim,nt);
if isfield(targinfo, 'd')
    targd = targinfo.d;
end

if isfield(targinfo, 'd2')
    targd2 = targinfo.d2;
end

if isfield(targinfo, 'n')
    targn = targinfo.n;
end
datat = [];
if isfield(targinfo,'data')
    datat = targinfo.data;
end


fints = zeros(opdims(1)*nt,1);

% using adaptive quadrature

[t,w] = lege.exps(2*k+1);
ct = lege.exps(k);
bw = lege.barywts(k);
r = chnkr.r;
d = chnkr.d;
n = chnkr.n;
d2 = chnkr.d2;
data = chnkr.data;


if isempty(flag) % do all to all adaptive
    for i = 1:nch
        for j = 1:nt
            datat2 = [];
            if ~isempty(datat)
                datat2 = datat(:,j);
            end
            fints1 = chnk.adapgausskerneval(r,d,n,d2,data,ct,bw,i,dens,targs(:,j), ...
                    targd(:,j),targn(:,j),targd2(:,j),datat2,kerneval,opdims,t,w,opts);
            
            indj = (j-1)*opdims(1);
            ind = indj(:).' + (1:opdims(1)).'; ind = ind(:);
            fints(ind) = fints(ind) + fints1;
        end
    end
else % do only those flagged
    for i = 1:nch
        [ji] = find(flag(:,i));
        datat2 = [];
        if ~isempty(datat)
            datat2 = datat(:,ji);
        end
        [fints1,maxrec,numint,iers] =  chnk.adapgausskerneval(r,d,n,d2,data,ct,bw,i,dens,targs(:,ji), ...
                    targd(:,ji),targn(:,ji),targd2(:,ji),datat2,kerneval,opdims,t,w,opts);
                
        indji = (ji-1)*opdims(1);
        ind = (indji(:)).' + (1:opdims(1)).';
        ind = ind(:);
        fints(ind) = fints(ind) + fints1;        

    end
    
end

end