function [fints,ids] = chunkerkerneval(chnkobj,kern,dens,targobj,opts)
%CHUNKERKERNEVAL compute the convolution of the integral kernel with
% the density defined on the chunk geometry. 
%
% Syntax: fints = chunkerkerneval(chnkr,kern,dens,targs,opts)
%
% Input:
%   chnkobj - chunker object or chunkgraph object description of curve
%   kern - kernel class object or kernel function taking inputs 
%                      kern(srcinfo,targinfo). if matrix of kernels 
%                      then must have dimensions nregion x nedge or 
%                      nregion x 1 or 1 x nedge, where nregion is the
%                      number of regions in the chunkgraph and nedge is the
%                      number of edges
%   dens - density on boundary, should have size opdims(2) x k x nch
%          where k = chnkr.k, nch = chnkr.nch, where opdims is the 
%          size of kern for a single src,targ pair.
%   targobj - object describing the target points, can be specified as
%       * array of points
%       * chunker object
%       * chunkgraph object
%
% Optional input:
%   opts - structure for setting various parameters
%       opts.flam - if = true, use flam utilities. to be replaced by the 
%                   opts.forceflam flag. 
%                   opts.flam supercedes opts.accel, if
%                   both are true, then flam will be used. (false)
%       opts.accel - if = true, use specialized fmm if defined 
%                   for the kernel or use a generic FLAM fmm to accelerate
%                   the smooth part of the eval. if false do direct. (true)
%       opts.proxybylevel - if = true, determine the number of
%                   necessary proxy points adaptively at each level of the 
%                   factorization in ifmm. Typically needed only for 
%                   moderate / high frequency problems. (false)
%                   for the kernel, if it doesnt exist or if too few 
%                   sources/targets, or if false, 
%                   do direct. (true)
%       opts.forcefmm - if = true, use specialized fmm if defined,
%                   independent of the number of sources/targets. (false)
%       opts.forcesmooth - if = true, only use the smooth integration rule
%                           (false)
%       opts.cormat - sparse matrix of corrections to the smooth quadrature rule
%            generated by chunkerkernevalmat with option corrections =
%            true, useful if there are repeated calls with the same targets points
%       opts.forceadap - if = true, only use adaptive quadrature (false)
%    NOTE: only one of forcesmooth or forceadap is allowed. If both 
%           false, a hybrid algorithm is used, where the smooth rule is 
%           applied for targets separated by opts.fac*length of chunk from
%           a given chunk and adaptive integration is used otherwise
%       opts.fac = the factor times the chunk length used to decide 
%               between adaptive/smooth rule
%       opts.eps = tolerance for adaptive integration
%
% output:
%   fints - opdims(1) x nt array of integral values where opdims is the 
%           size of kern for a single input (dimension of operator output)
%   ids - a size nt integer array. if chnkrobj is a chunkgraph, ids(i) is
%           the ID number of the region containing the ith target. if
%           chnkrobj is a chunker, then ids is simply an array of all 1s.
%

% TODO: find a method for using proxy surfaces while still not performing
%   the add/subtract strategy...

% author: Travis Askham (askhamwhat@gmail.com)

% determine operator dimensions using first two points

% Assign appropriate object to chnkr
icgrph = false;
nregion = 1;
nedge = 1;
if class(chnkobj) == "chunker"
   chnkr = chnkobj;
   nedge = length(chnkr);
elseif class(chnkobj) == "chunkgraph"
   chnkr = chnkobj.echnks;
   nregion = length(chnkobj.regions);
   nedge = length(chnkr);
   icgrph = true;
else
    msg = "CHUNKERKERNEVAL: first input is an unsupported object";
    error(msg)
end

if ~isa(kern,'kernel')
    try 
        kern = kernel(kern);
    catch
        error('CHUNKERKERNEVAL: second input kern not of supported type');
    end
end

[mk,nk] = size(kern);
assert(or(mk == 1,mk == nregion),...
    "CHUNKERKERNEVAL: second input not of appropriate shape " + ...
    "number of rows in kern should be 1 or nregion")
assert(or(nk == 1,nk == nedge),...
    "CHUNKERKERNEVAL: second input not of appropriate shape " + ...
    "number of cols in kern should be 1 or nedge")

if nk == 1 && length(chnkr) > 1
    chnkr = merge(chnkr);
end


if nargin < 5
    opts = [];
end

opts_use = [];
opts_use.forcesmooth = false;
opts_use.forceadap = false;
opts_use.forcepquad = false;
opts_use.flam = false;
opts_use.accel = true;
opts_use.forcefmm = false;
opts_use.fac = 1.0;
opts_use.eps = 1e-12;
opts_use.proxybylevel = false;
cormat = [];
if isfield(opts,'forcesmooth'); opts_use.forcesmooth = opts.forcesmooth; end
if isfield(opts,'forceadap'); opts_use.forceadap = opts.forceadap; end
if isfield(opts,'forcepquad'); opts_use.forcepquad = opts.forcepquad; end
if isfield(opts,'side'); opts_use.side = opts.side; end
if isfield(opts,'flam')
    opts_use.flam = opts.flam;
end
if isfield(opts,'cormat')
    cormat = opts.cormat;
    opts_use.forcesmooth = true;
    opts_use.forceadap = false;
    opts_use.forcepquad = false;
end
if isfield(opts,'accel'); opts_use.accel = opts.accel; end
if isfield(opts,'fac'); opts_use.fac = opts.fac; end
if isfield(opts,'eps'); opts_use.eps = opts.eps; end
if isfield(opts,'proxybylevel'); opts_use.proxybylevel = opts.proxybylevel; end

% Assign appropriate object to targinfo
targinfo = [];
if isa(targobj, "chunker") || isa(targobj, "chunkgraph")
    targinfo.r = targobj.r(:,:);
    targinfo.d = targobj.d(:,:);
    targinfo.d2 = targobj.d2(:,:);
    targinfo.n = targobj.n(:,:);
elseif isstruct(targobj)
    if isfield(targobj,"r")
        targinfo.r = targobj.r(:,:);
    else
        error("CHUNKERKERNEVAL: input 4 must at least have positions " + ...
            "defined");
    end
    if isfield(targobj,"d"); targinfo.d = targobj.d(:,:); end
    if isfield(targobj,"d2"); targinfo.d2 = targobj.d2(:,:); end
    if isfield(targobj,"n"); targinfo.n = targobj.n(:,:); end
    if isfield(targobj,"data"); targinfo.data = targobj.data(:,:); end
elseif isnumeric(targobj)
    targinfo.r = targobj;
else
    error("CHUNKERKERNEVAL: input 4 is not a supported type");
end

if icgrph && mk > 1
    ids = chunkgraphinregion(chnkobj,targinfo.r);
else
    ids = ones(size(targinfo.r,2),1);
end

[dim,~] = size(targinfo.r);

if (dim ~= 2); warning('only dimension two tested'); end

opdims_mat = zeros(2,mk,nk);
ntargs = zeros(mk,1);
npts = zeros(nk,1);

datadim = 0;
if isfield(targinfo,'data') && ~isempty(targinfo.data)
    datadim = size(targinfo.data,1);
end

for iii=1:mk
    itarg = (ids == iii);    
    ntargs(iii) = nnz(itarg);

    targinfotmp = [];
    targinfotmp.r = randn(dim,1); targinfotmp.d = randn(dim,1);
    targinfotmp.d2 = randn(dim,1); targinfotmp.n = randn(dim,1);
    targinfotmp.data = randn(datadim,1);
    
    for jjj=1:nk
        
        % determine operator dimensions using a boundary point and random
        % targ
        
        srcinfo = []; 
        srcinfo.r = chnkr(jjj).r(:,1); srcinfo.d = chnkr(jjj).d(:,1); 
        srcinfo.d2 = chnkr(jjj).d2(:,1); srcinfo.n = chnkr(jjj).n(:,1);
        if ~isempty(chnkr(jjj).data)
            srcinfo.data = chnkr(jjj).data(:,1);
        end
        npts(jjj) = chnkr(jjj).npt; 

        try
            ftemp = kern(iii,jjj).eval(srcinfo,targinfotmp);
        catch
            error("failed to determine size of kernel (%d, %d)",iii,jjj);
        end
        opdims = size(ftemp);
        opdims_mat(:,iii,jjj) = opdims;
    end
end    

% indexing

icollocs = zeros(nk+1,1);
icollocs(1)=1;
for jjj=1:nk
    icollocs(jjj+1) = icollocs(jjj) + npts(jjj)*opdims_mat(2,1,jjj);
end

rowdims = opdims_mat(1,:,1); rowdims = rowdims(:);
nout = sum(ntargs(:).*rowdims(:));
fints = zeros(nout,1);
if ~isempty(cormat)
    if nout ~= size(cormat,1)
        error('cormat size is incorrect\n')
    end
end

ntarg = size(targinfo.r(:,:),2);
itargstart = zeros(ntarg+1,1);
itargstart(2:end) = rowdims(ids(:));
itargstart = 1+cumsum(itargstart);

for iii = 1:mk
% loop over relevant regions 
itarg = (ids == iii);
if nnz(itarg) == 0
    continue
end

targinfo0 = [];
targinfo0.r = targinfo.r(:,itarg);
if isfield(targinfo,"d"); targinfo0.d = targinfo.d(:,itarg); end
if isfield(targinfo,"d2"); targinfo0.d2 = targinfo.d2(:,itarg); end
if isfield(targinfo,"n"); targinfo0.n = targinfo.n(:,itarg); end
if isfield(targinfo,"data") && ~isempty(targinfo.data); targinfo0.data = targinfo.data(:,itarg); end

irow0 = kron(itargstart(itarg),ones(rowdims(iii),1)) + repmat( (0:(rowdims(iii)-1)).',nnz(itarg),1);

for jjj = 1:nk
% loop over relevant boundary components

kern0 = kern(iii,jjj);
if kern0.isnan
    fints(irow0) = nan;
    continue
end
if kern0.iszero
    continue
end

chnkr0 = chnkr(jjj);
opdims0 = opdims_mat(:,iii,jjj);
dens0 = dens(icollocs(jjj):(icollocs(jjj+1)-1));

if opts_use.forcesmooth
    fints(irow0) = fints(irow0) + chnk.chunkerkerneval_smooth(chnkr0,kern0,opdims0,dens0,targinfo0, ...
        [],opts_use);
    continue
end

if opts_use.forceadap
    fints(irow0) = fints(irow0) + chunkerkerneval_adap(chnkr0,kern0,opdims0,dens0, ...
        targinfo0,[],opts_use);
    continue
end


if opts_use.forcepquad
    optsflag = []; optsflag.fac = opts_use.fac;
    flag = flagnear(chnkr0,targinfo.r,optsflag);
    fints(irow0) = fints(irow0) + chnk.chunkerkerneval_smooth(chnkr0,kern0,opdims0,dens0,targinfo0, ...
        flag,opts_use);

    if ~isfield(opts_use,'side')
        msg = "Error: for pquad, set opts.side to 'i' or 'e' ";
        error(msg)  
    end

    fints(irow0) = fints(irow0) + chunkerkerneval_pquad(chnkr0,kern0,opdims0,dens0, ...
        targinfo0,flag,opts_use);

    return
end

% smooth for sufficiently far, adaptive otherwise

rho = 1.8;
optsflag = [];  optsflag.rho = rho;
flag = flagnear_rectangle(chnkr0,targinfo0.r,optsflag);

npoly = chnkr0.k*2;
nlegnew = chnk.ellipse_oversample(rho,npoly,opts_use.eps);
nlegnew = max(nlegnew,chnkr0.k);

[chnkr02,dens02] = upsample(chnkr0,nlegnew,dens0);
fints(irow0) = fints(irow0) + chnk.chunkerkerneval_smooth(chnkr02,kern0,opdims0,dens02,targinfo0, ...
    flag,opts_use);

fints(irow0) = fints(irow0) + chunkerkerneval_adap(chnkr0,kern0,opdims0,dens0, ...
        targinfo0,flag,opts_use);

end
end

if ~isempty(cormat)
    fints = fints + cormat*dens;
end

end

function fints = chunkerkerneval_pquad(chnkr,kern,opdims,dens, ...
    targinfo,flag,opts)

if ~isa(kern,'kernel') || isempty(kern.splitinfo)
    error('Helsing-Ojala quad only available for kernel class objects with splitinfo defined');
end

% target
[~,nt] = size(targinfo.r);
fints = zeros(opdims(1)*nt,1);
k = chnkr.k;
nch = chnkr.nch;
[t,w] = lege.exps(2*k);
ct = lege.exps(k);
bw = lege.barywts(k);
r = chnkr.r;
d = chnkr.d;
n = chnkr.n;
d2 = chnkr.d2;
wts = chnkr.wts;

assert(numel(dens) == opdims(2)*k*nch,'dens not of appropriate size')
dens = reshape(dens,opdims(2),k,nch);

% interpolation matrix
intp = lege.matrin(k,t);          % interpolation from k to 2*k
intp_ab = lege.matrin(k,[-1;1]);  % interpolation from k to end points

targs = targinfo.r;

for j=1:size(chnkr.r,3)
    [ji] = find(flag(:,j));
    if(~isempty(ji))
        idxjmat = (j-1)*k+(1:k);

        targinfoji = [];
        targinfoji.r = targinfo.r(:,ji);
        if isfield(targinfo, 'd')
            targinfoji.d = targinfo.d(:,ji);
        end

        if isfield(targinfo, 'd2')
            targinfoji.d2 = targinfo.d2(:,ji);
        end

        if isfield(targinfo, 'n')
            targinfoji.n = targinfo.n(:,ji);
        end        

        srcinfo = [];
        srcinfo.r = r(:,:,j);
        srcinfo.d = d(:,:,j);
        srcinfo.d2 = d2(:,:,j);
        srcinfo.n = n(:,:,j);
        densj = dens(:,:,j);
        indji = (ji-1)*opdims(1);
        ind = (indji(:)).' + (1:opdims(1)).';

        % Helsing-Ojala (interior/exterior?)
        allmatsf = cell(size(kern.splitinfo.type));
        [allmatsf{:}] = chnk.pquadwts(r,d,n,d2,wts,j,targs(:,ji),t,w, ...
            opts,intp_ab,intp,kern.splitinfo.type,true);

        r_i = intp*(r(1,:,j)'+1i*r(2,:,j)'); 
        d_i = (intp*(d(1,:,j)'+1i*d(2,:,j)'));
        d2_i = (intp*(d(1,:,j)'+1i*d(2,:,j)'));
        sp = abs(d_i); tang = d_i./sp; 
        n_i = -1i*tang; 
        srcinfof = [];
        srcinfof.r  = [real(r_i)  imag(r_i)]';
        srcinfof.d  = [real(d_i)  imag(d_i)]';
        srcinfof.d2 = [real(d2_i) imag(d2_i)]';
        srcinfof.n  = [real(n_i)  imag(n_i)]';

        funsf = kern.splitinfo.functions(srcinfof,targinfoji);
        for l = 1:length(allmatsf)
            switch kern.splitinfo.action{l}
                case 'r'
                    mat0 = real(allmatsf{l});
                case 'i'
                    mat0 = imag(allmatsf{l});
                case 'c'
                    mat0 = allmatsf{l};
            end
            mat0opdim = kron(mat0,ones(opdims'));
            mat0xsplitfun = mat0opdim.*funsf{l};
            densfj = densj*intp';
            fints(ind(:)) = fints(ind(:)) + mat0xsplitfun*densfj(:);
        end
    end
end
end



function fints = chunkerkerneval_adap(chnkr,kern,opdims,dens, ...
    targinfo,flag,opts)

if isa(kern,'kernel')
    kerneval = kern.eval;
else
    kerneval = kern;
end

k = chnkr.k;
nch = chnkr.nch;

if nargin < 6
    flag = [];
end
if nargin < 7
    opts = [];
end

assert(numel(dens) == opdims(2)*k*nch,'dens not of appropriate size')
dens = reshape(dens,opdims(2),k,nch);

% Extract target info
targs = targinfo.r;
[~,nt] = size(targs);
targd = zeros(chnkr.dim,nt); targd2 = zeros(chnkr.dim,nt);
targn = zeros(chnkr.dim,nt);
if isfield(targinfo, 'd')
    targd = targinfo.d;
end

if isfield(targinfo, 'd2')
    targd2 = targinfo.d2;
end

if isfield(targinfo, 'n')
    targn = targinfo.n;
end
datat = [];
if isfield(targinfo,'data')
    datat = targinfo.data;
end


fints = zeros(opdims(1)*nt,1);

% using adaptive quadrature

[t,w] = lege.exps(2*k+1);
ct = lege.exps(k);
bw = lege.barywts(k);
r = chnkr.r;
d = chnkr.d;
n = chnkr.n;
d2 = chnkr.d2;
data = chnkr.data;


if isempty(flag) % do all to all adaptive
    for i = 1:nch
        for j = 1:nt
            datat2 = [];
            if ~isempty(datat)
                datat2 = datat(:,j);
            end
            fints1 = chnk.adapgausskerneval(r,d,n,d2,data,ct,bw,i,dens,targs(:,j), ...
                    targd(:,j),targn(:,j),targd2(:,j),datat2,kerneval,opdims,t,w,opts);
            
            indj = (j-1)*opdims(1);
            ind = indj(:).' + (1:opdims(1)).'; ind = ind(:);
            fints(ind) = fints(ind) + fints1;
        end
    end
else % do only those flagged
    for i = 1:nch
        [ji] = find(flag(:,i));
        datat2 = [];
        if ~isempty(datat)
            datat2 = datat(:,ji);
        end
        [fints1,maxrec,numint,iers] =  chnk.adapgausskerneval(r,d,n,d2,data,ct,bw,i,dens,targs(:,ji), ...
                    targd(:,ji),targn(:,ji),targd2(:,ji),datat2,kerneval,opdims,t,w,opts);
                
        indji = (ji-1)*opdims(1);
        ind = (indji(:)).' + (1:opdims(1)).';
        ind = ind(:);
        fints(ind) = fints(ind) + fints1;        

    end
    
end

end